# Volumes
  
Docker volumes are the preferred mechanism for persisting data generated by and used by Docker containers. They provide a way to store data outside the container's writable layer, ensuring data persistence even when the container is stopped, removed, or recreated.  
  
`docker volume create` : create a volume explicitly  
  
When you create a volume, it's stored within a directory on the Docker host. When you mount the volume into a container, this directory is what's mounted into the container. This is similar to the way that bind mounts work, except that volumes are managed by Docker and are isolated from the core functionality of the host machine  
  
When to use
------------
  
Volumes are the preferred mechanism for persisting data generated by and used by Docker containers. While `bind mounts` are dependent on the directory structure and OS of the host machine, volumes are completely managed by Docker. Volumes are a good choice for the following use cases:
- Volumes are easier to back up or migrate than bind mounts.
- You can manage volumes using Docker CLI commands or the Docker API.
- Volumes work on both Linux and Windows containers.
- Volumes can be more safely shared among multiple containers.
- New volumes can have their content pre-populated by a container or build.
- When your application requires high-performance I/O.
  
**Do not use volumes if** you need to access the files from the host, as the volume is completely managed by Docker. Use `bind mounts` if you need to access files or directories from both containers and the host.  
  
`Volumes` are often a **better choice** than writing data directly to a container, because a volume **doesn't increase the size** of the containers using it. Using a volume is also **faster**; writing into a container's writable layer requires a storage driver to manage the filesystem. The storage driver provides a union filesystem, using the Linux kernel. This extra abstraction reduces performance as compared to using volumes, which write directly to the host filesystem.  
  
If your container generates **non-persistent** state data, consider using a `tmpfs mount` to avoid storing the data anywhere permanently, and to increase the container's performance by avoiding writing into the container's writable layer.  
  
Volumes use `rprivate` (recursive private) bind propagation, and bind propagation isn't configurable for volumes.  
  
Lifecycle
-----------
  
A volume's contents exist outside the lifecycle of a given container. When a container is destroyed, the writable layer is destroyed with it. Using a volume ensures that the data is persisted even if the container using it is removed.  
  
A given volume can be mounted into multiple containers simultaneously. When no running container is using a volume, the volume is still available to Docker and isn't removed automatically. You can remove unused volumes using docker volume prune.  
  
Mounting a volume over existing data
-------------------------------------
  
If you mount a non-empty volume into a directory in the container in which files or directories exist, the pre-existing files are obscured by the mount.  
  
With containers, there's no straightforward way of removing a mount to reveal the obscured files again. Your best option is to recreate the container without the mount.  
  
If you mount an empty volume into a directory in the container in which files or directories exist, these files or directories are propagated (copied) into the volume by default. Similarly, if you start a container and specify a volume which does not already exist, an empty volume is created for you. This is a good way to pre-populate data that another container needs.  
  
To prevent Docker from copying a container's pre-existing files into an empty volume, use the volume-nocopy option.  
  
Named and anonymous volumes
----------------------------
  
A volume may be `named` or `anonymous`. `Anonymous` volumes are given a **random name** that's guaranteed to be unique within a given Docker host. Just like `named` volumes, `anonymous` volumes **persist** even if you remove the container that uses them, except if you use the `--rm` flag when creating the container, in which case the `anonymous` volume associated with the container is **destroyed**.  
  
If you create multiple containers consecutively that each use `anonymous` volumes, **each container creates its own volume**. `Anonymous` volumes **aren't reused** or shared between containers automatically. To share an anonymous volume between two or more containers, you must mount the anonymous volume using the random volume ID.
  
Syntax
--------
  
```
docker run --mount type=volume,src=<volume-name>,dst=<mount-path>
docker run --volume <volume-name>:<mount-path>
```
  
In general, `--mount` is preferred. The main difference is that the `--mount` flag is more **explicit** and supports all the available **options**.

1. Options for `--mount type=volume`:
    - `source`, `src`: The source of the mount. For named volumes, this is the name of the volume. For anonymous volumes, this field is omitted.
    - `destination`, `dst`, `target`: The path where the file or directory is mounted in the container.
    - `volume-subpath`: A path to a subdirectory within the volume to mount into the container. The subdirectory must exist in the volume before the volume is mounted to a container.
    - `readonly`, `ro`: If present, causes the volume to be mounted into the container as read-only.
    - `volume-nocopy`: If present, data at the destination isn't copied into the volume if the volume is empty. By default, content at the target destination gets copied into a mounted volume if empty.
    - `volume-opt`: Can be specified more than once, takes a key-value pair consisting of the option name and its value.
    Example:  
    `docker run --mount type=volume,src=myvolume,dst=/data,ro,volume-subpath=/foo`

2. Options for `--volume`:
    - `readonly`, `ro`: If present, causes the volume to be mounted into the container as read-only.
    - `volume-nocopy`: If present, data at the destination isn't copied into the volume if the volume is empty. By default, content at the target destination gets copied into a mounted volume if empty.
    Example:  
    `docker run -v myvolume:/data:ro`

Useful:  
```
docker volume create my-vol
docker volume ls
docker volume inspect my-vol
docker volume rm my-vol

docker run -d --name devtest --mount source=myvol2,target=/app nginx:latest

docker inspect devtest          # to verify that Docker created the volume and it mounted correctly
```
Docker Compose:  
```
services:
  frontend:
    image: node:lts
    volumes:
      - myapp:/home/node/app
volumes:
  myapp:
    # external: true            # optional, for outside vol
```
`docker service create -d --replicas=4 --name devtest-service --mount source=myvol2,target=/app nginx:latest'
  
Further reading: https://docs.docker.com/engine/storage/volumes/